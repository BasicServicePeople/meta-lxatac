From: Ahmad Fatoum <a.fatoum@pengutronix.de>
Date: Fri, 20 May 2022 17:41:12 +0200
Subject: [PATCH] bbu: move barebox_update eMMC boot handling into common code

Like with the i.MX, the STM32MP1 BootROM also consults the
EXT_CSD_PARTITION_CONFIG register to find out what to boot.

The barebox_update code used for atomic update on i.MX is thus
useful to the STM32MP as well, so move the boot switching part
to a generic location.

Signed-off-by: Ahmad Fatoum <a.fatoum@pengutronix.de>
---
 arch/arm/mach-imx/imx-bbu-internal.c | 48 ++-----------------------------
 common/bbu.c                         | 55 ++++++++++++++++++++++++++++++++++++
 include/bbu.h                        |  3 ++
 3 files changed, 61 insertions(+), 45 deletions(-)

diff --git a/arch/arm/mach-imx/imx-bbu-internal.c b/arch/arm/mach-imx/imx-bbu-internal.c
index 64d4d77ff596..3b0c587cc572 100644
--- a/arch/arm/mach-imx/imx-bbu-internal.c
+++ b/arch/arm/mach-imx/imx-bbu-internal.c
@@ -422,54 +422,12 @@ static int imx_bbu_update(struct bbu_handler *handler, struct bbu_data *data)
 static int imx_bbu_internal_mmcboot_update(struct bbu_handler *handler,
 					   struct bbu_data *data)
 {
-	struct bbu_data _data = *data;
 	int ret;
-	char *bootpartvar;
-	const char *bootpart;
-	char *devicefile;
-	const char *devname = devpath_to_name(data->devicefile);
 
-	ret = device_detect_by_name(devname);
-	if (ret) {
-		pr_err("Couldn't detect device '%s'\n", devname);
-		return ret;
-	}
-
-	ret = asprintf(&bootpartvar, "%s.boot", devname);
-	if (ret < 0)
-		return ret;
-
-	bootpart = getenv(bootpartvar);
-	if (!bootpart) {
-		pr_err("Couldn't read the value of '%s'\n", bootpartvar);
-		ret = -ENOENT;
-		goto free_bootpartvar;
-	}
-
-	if (!strcmp(bootpart, "boot0")) {
-		bootpart = "boot1";
-	} else {
-		bootpart = "boot0";
-	}
-
-	ret = asprintf(&devicefile, "/dev/%s.%s", devname, bootpart);
-	if (ret < 0)
-		goto free_bootpartvar;
-
-	_data.devicefile = devicefile;
-
-	ret = imx_bbu_update(handler, &_data);
-	if (ret)
-		goto free_devicefile;
-
-	/* on success switch boot source */
-	ret = setenv(bootpartvar, bootpart);
-
-free_devicefile:
-	free(devicefile);
+	ret = bbu_mmcboot_handler(handler, data, imx_bbu_update);
 
-free_bootpartvar:
-	free(bootpartvar);
+	if (ret == -ENOENT)
+		pr_err("Couldn't read the value of .boot parameter\n");
 
 	return ret;
 }
diff --git a/common/bbu.c b/common/bbu.c
index cd7bdc40b72a..6a47b21a55b0 100644
--- a/common/bbu.c
+++ b/common/bbu.c
@@ -19,6 +19,7 @@
 #include <malloc.h>
 #include <linux/stat.h>
 #include <image-metadata.h>
+#include <environment.h>
 #include <file-list.h>
 
 static LIST_HEAD(bbu_image_handlers);
@@ -304,6 +305,60 @@ struct bbu_std {
 	enum filetype filetype;
 };
 
+int bbu_mmcboot_handler(struct bbu_handler *handler, struct bbu_data *data,
+			int (*chained_handler)(struct bbu_handler *, struct bbu_data *))
+{
+	struct bbu_data _data = *data;
+	int ret;
+	char *bootpartvar;
+	const char *bootpart;
+	char *devicefile;
+	const char *devname = devpath_to_name(data->devicefile);
+
+	ret = device_detect_by_name(devname);
+	if (ret) {
+		pr_err("Couldn't detect device '%s'\n", devname);
+		return ret;
+	}
+
+	ret = asprintf(&bootpartvar, "%s.boot", devname);
+	if (ret < 0)
+		return ret;
+
+	bootpart = getenv(bootpartvar);
+	if (!bootpart) {
+		ret = -ENOENT;
+		goto free_bootpartvar;
+	}
+
+	if (!strcmp(bootpart, "boot0")) {
+		bootpart = "boot1";
+	} else {
+		bootpart = "boot0";
+	}
+
+	ret = asprintf(&devicefile, "/dev/%s.%s", devname, bootpart);
+	if (ret < 0)
+		goto free_bootpartvar;
+
+	_data.devicefile = devicefile;
+
+	ret = chained_handler(handler, &_data);
+	if (ret < 0)
+		goto free_devicefile;
+
+	/* on success switch boot source */
+	ret = setenv(bootpartvar, bootpart);
+
+free_devicefile:
+	free(devicefile);
+
+free_bootpartvar:
+	free(bootpartvar);
+
+	return ret;
+}
+
 static int bbu_std_file_handler(struct bbu_handler *handler,
 					struct bbu_data *data)
 {
diff --git a/include/bbu.h b/include/bbu.h
index 3128339068ee..bf5f2158df72 100644
--- a/include/bbu.h
+++ b/include/bbu.h
@@ -50,6 +50,9 @@ void bbu_handlers_list(void);
 
 struct file_list;
 
+int bbu_mmcboot_handler(struct bbu_handler *, struct bbu_data *,
+			int (*chained_handler)(struct bbu_handler *, struct bbu_data *));
+
 #ifdef CONFIG_BAREBOX_UPDATE
 
 int bbu_register_handler(struct bbu_handler *);
